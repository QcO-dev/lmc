{"version":3,"sources":["assembler.js","emulator.js","editor-config.js","examples.js","Description.js","App.js","index.js"],"names":["INSTRUCTIONS","UNARY_INSTRUCTIONS","UNARY_INSTRUCTION_CODE_MAP","BINARY_INSTRUCTION_FIRST_VALUE","assemble","source","memory","Array","fill","lines","split","filter","v","length","map","l","i","replace","w","word","line","isNaN","parseInt","parseFloat","includes","type","value","match","toToken","toUpperCase","labels","ip","slice","words","flat","error","errorLoc","memoryAddress","instruction","opcode","operand","form","toString","padStart","step","inIp","registers","output","wasWaitingForInput","input","pc","strMemValue","data","ir","ar","halt","waitingForInput","ac","offset","location","String","fromCharCode","languageDef","defaultToken","keywords","x","toLowerCase","tokenizer","root","include","cases","whitespace","configuration","comments","lineComment","examples","join","Description","className","defaultString","editorWillMount","monaco","languages","getLanguages","some","id","register","setMonarchTokensProvider","setLanguageConfiguration","App","editorRef","useRef","useState","setMemory","currentIp","setCurrentIp","setRegisters","setOutput","setError","setInput","setWaitingForInput","isHalted","setHalted","changedMemoryAddresses","setChangedMemoryAddresses","isAccumulatorChanged","setAccumulatorChanged","inputSpeed","setInputSpeed","speed","setSpeed","submitRef","loopRef","getColourBorder","condition","subcondition","stopCode","clearInterval","current","onClick","assembleResult","getValue","assembleCode","localMem","localReg","out","waiting","setInterval","memoryBefore","accumulatorBefore","changedMem","push","height","width","language","theme","defaultValue","beforeMount","onMount","editor","_monaco","onSubmit","event","charAt","substring","preventDefault","autoComplete","autoCapitalize","autoCorrect","htmlFor","name","onChange","target","setValue","Object","keys","e","per10mem","chunk","values","j","renderMemory","regToName","entries","style","minWidth","renderRegisters","href","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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,uBAAwB,CACxBC,MAAO,CACN,YAAa,UACb,WAAY,qBAGd,CAAC,MAAO,WAETC,WAAY,CACX,CAAC,aAAc,SACf,CAAC,UAAc,cAKLC,EAAgB,CAC5BC,SAAU,CACRC,YAAa,OCzBHC,EAAW,CACvB,SAAY,CACX,wDACA,cACA,oBACA,cACA,oBACA,cACA,cACA,iBACCC,KAAK,MACP,OAAQ,CACP,0CACA,gEACA,6BACA,cACA,mBACA,GACA,0EACA,iBACA,mBACA,mBACA,kBACA,GACA,8DACA,mBACA,cACA,kBACA,mBACA,kBACA,GACA,cACA,GACA,0CACA,gBACA,gBACA,gBACA,iBACCA,KAAK,MACP,IAAO,CACN,kEACA,cACA,oBACA,cACA,qBACA,qEACA,oBACA,sBACA,2DACA,oBACA,cACA,kBACA,GACA,mBACA,qBACA,cACA,GACA,cACA,GACA,eACA,gBACA,iBACCA,KAAK,MACP,SAAY,CACX,qDACA,GACA,wBACA,cACA,mBACA,cACA,mBACA,GACA,qCACA,kBACA,mDACA,sBACA,mBACA,sBACA,2BACA,mBACA,kBACA,mBACA,sCACA,mBACA,GACA,mDACA,sBACA,cACA,cACA,GACA,eACA,gBACA,gBACA,gBACA,GACA,gBACA,iBACCA,KAAK,MACP,OAAU,CACT,sBACA,YACA,iBACA,YACA,iBACA,SACA,wDACA,GACA,iBACA,iBACA,0DACA,iBACA,iBACA,GACA,iBACA,kBACA,gBACA,kBACA,iBACA,GACA,qEACA,kBACA,YACA,iBACA,gBACA,YACA,YACA,GACA,eACA,cACA,cACA,cACA,gBACA,eACCA,KAAK,MACP,MAAS,CACR,2DACA,+CACA,GACA,4EACA,qBACA,qBACA,kBACA,GACA,qCACA,qBACA,cACA,+BACA,kBACA,qBACA,kBACA,GACA,cACA,GACA,6CACA,iBACA,yDACA,kBACA,gBACA,iBACCA,KAAK,MACP,cAAe,CACd,qDACA,sDACA,qBACA,qBACA,kBACA,oBACA,kBACA,GACA,0DACA,uDACA,qBACA,sCACA,oBACA,0DACA,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","file":"static/js/main.8710de0e.chunk.js","sourcesContent":["// Returns the memory array\r\n\r\nconst INSTRUCTIONS = [\"LDA\", \"STA\", \"LOA\", \"ADD\", \"SUB\", \"INP\", \"OUT\", \"OTC\", \"HLT\", \"BRZ\", \"BRP\", \"BRA\", \"DAT\"];\r\nconst UNARY_INSTRUCTIONS = [\"INP\", \"OUT\", \"OTC\", \"HLT\"];\r\n\r\nconst UNARY_INSTRUCTION_CODE_MAP = {\r\n\t\"INP\": 901,\r\n\t\"OUT\": 902,\r\n\t\"OTC\": 912,\r\n\t\"HLT\": 0\r\n}\r\n\r\nconst BINARY_INSTRUCTION_FIRST_VALUE = {\r\n\t\"LDA\": \"5\",\r\n\t\"STA\": \"3\",\r\n\t\"LOA\": \"4\",\r\n\t\"ADD\": \"1\",\r\n\t\"SUB\": \"2\",\r\n\t\"BRZ\": \"7\",\r\n\t\"BRP\": \"8\",\r\n\t\"BRA\": \"6\",\r\n\t\"DAT\": \"\"\r\n}\r\n\r\nconst toToken = (word, line) => {\r\n\tif(!isNaN(word) && parseInt(word) === parseFloat(word)) {\r\n\t\treturn {\r\n\t\t\ttype: \"int\",\r\n\t\t\tvalue: parseInt(word),\r\n\t\t\tline\r\n\t\t}\r\n\t}\r\n\telse if(INSTRUCTIONS.includes(word)) {\r\n\t\treturn {\r\n\t\t\ttype: \"instruction\",\r\n\t\t\tvalue: word,\r\n\t\t\tline\r\n\t\t}\r\n\t}\r\n\telse if(word.match(/^[A-Z][A-Z0-9]*$/)) {\r\n\t\treturn {\r\n\t\t\ttype: \"label\",\r\n\t\t\tvalue: word,\r\n\t\t\tline\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\treturn {\r\n\t\t\ttype: \"invalid\",\r\n\t\t\tvalue: word,\r\n\t\t\tline\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport const assemble = (source) => {\r\n\tconst memory = new Array(100).fill(0);\r\n\r\n\tconst rawLines = source.split(/\\r?\\n/).filter(v => v.length !== 0);\r\n\r\n\tlet lines = rawLines.map((l, i) => l.replace(/\\/\\/.*?$/, \"\").split(/\\s+/).filter(v => v.length !== 0).map(w => toToken(w.toUpperCase(), i + 1)))\r\n\t\t\t\t.filter(l => l.length !== 0);\r\n\r\n\tconst labels = {}\r\n\tlet ip = 0;\r\n\tfor(let i = 0; i < lines.length; i++) {\r\n\t\tlet line = lines[i];\r\n\r\n\t\tif(line[0].type === \"label\") {\r\n\t\t\tlabels[line[0].value] = ip;\r\n\t\t\tlines[i] = line = line.slice(1)\r\n\t\t}\r\n\t\tip += line.filter(w => w.type === \"instruction\").length;\r\n\t}\r\n\tlines = lines.filter(l => l.length !== 0)\r\n\r\n\tconst words = lines.flat();\r\n\r\n\tfor(let word of words) {\r\n\t\tif(word.type === \"invalid\")\r\n\t\t\treturn {\r\n\t\t\t\tmemory: new Array(100).fill(0),\r\n\t\t\t\terror: `Unexpected token ${word.value}`,\r\n\t\t\t\terrorLoc: word\r\n\t\t\t}\r\n\t}\r\n\r\n\tlet memoryAddress = 0;\r\n\tfor(let i = 0; i < words.length; i++) {\r\n\t\tconst word = words[i];\r\n\r\n\t\tif(word.type === \"instruction\") {\r\n\t\t\tconst instruction = word.value;\r\n\r\n\t\t\tif(UNARY_INSTRUCTIONS.includes(instruction)) {\r\n\t\t\t\tmemory[memoryAddress] = UNARY_INSTRUCTION_CODE_MAP[instruction];\r\n\t\t\t\tmemoryAddress++;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconst opcode = BINARY_INSTRUCTION_FIRST_VALUE[instruction];\r\n\r\n\t\t\t\tconst operand = words[i + 1];\r\n\r\n\t\t\t\tlet form = opcode;\r\n\r\n\t\t\t\tif(operand.type === \"int\") {\r\n\t\t\t\t\tif(instruction === \"DAT\")\r\n\t\t\t\t\t\tform = operand.value.toString()\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tform += operand.value.toString().padStart(2, '0')\r\n\t\t\t\t}\r\n\t\t\t\telse if(operand.type === \"label\") {\r\n\t\t\t\t\tif(!(operand.value in labels)) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tmemory: new Array(100).fill(0),\r\n\t\t\t\t\t\t\terror: `Label ${operand.value} is not bound`,\r\n\t\t\t\t\t\t\terrorLoc: word\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(instruction === \"DAT\")\r\n\t\t\t\t\t\tform = labels[operand.value].toString()\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tform += labels[operand.value].toString().padStart(2, '0');\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tmemory: new Array(100).fill(0),\r\n\t\t\t\t\t\terror: `Expected value, got ${operand.value}`,\r\n\t\t\t\t\t\terrorLoc: word\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(form.length > 3) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tmemory: new Array(100).fill(0),\r\n\t\t\t\t\t\terror: `Values cannot exceed 3 digits (got ${form})`,\r\n\t\t\t\t\t\terrorLoc: word\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tmemory[memoryAddress] = parseInt(form)\r\n\t\t\t\tmemoryAddress++;\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn {\r\n\t\t\t\tmemory: new Array(100).fill(0),\r\n\t\t\t\terror: `Expected instruction, got ${word.value}`,\r\n\t\t\t\terrorLoc: word\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(memoryAddress > 99) {\r\n\t\t\treturn {\r\n\t\t\t\tmemory: new Array(100).fill(0),\r\n\t\t\t\terror: `Exceeded memory capacity of 100 @ ${word.value}`,\r\n\t\t\t\terrorLoc: word\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tmemory,\r\n\t\terror: null,\r\n\t\terrorLoc: null\r\n\t};\r\n}","export const step = (memory, inIp, registers, output, wasWaitingForInput, input) => {\r\n\tregisters.pc = inIp;\r\n\tconst memValue = memory[registers.pc++];\r\n\r\n\tconst strMemValue = memValue.toString().padStart(3, '0')\r\n\tconst instruction = parseInt(strMemValue[0])\r\n\tconst data = parseInt(strMemValue[1]) * 10 + parseInt(strMemValue[2])\r\n\r\n\tregisters.ir = instruction;\r\n\tregisters.ar = data;\r\n\r\n\tlet halt = false;\r\n\tlet waitingForInput = false;\r\n\r\n\tif(wasWaitingForInput && input) {\r\n\t\tregisters.ac = parseInt(input)\r\n\t}\r\n\r\n\tswitch(instruction) {\r\n\t\t// HLT\r\n\t\tcase 0:\r\n\t\t\thalt = true;\r\n\t\t\tbreak;\r\n\t\t// ADD\r\n\t\tcase 1:\r\n\t\t\tregisters.ac = registers.ac + memory[data];\r\n\t\t\tbreak;\r\n\t\t// SUB\r\n\t\tcase 2:\r\n\t\t\tregisters.ac = registers.ac - memory[data];\r\n\t\t\tbreak;\r\n\t\t// STA\r\n\t\tcase 3:\r\n\t\t\tmemory[data] = registers.ac;\r\n\t\t\tbreak;\r\n\t\t// LOA\r\n\t\tcase 4: {\r\n\t\t\tconst offset = registers.ac;\r\n\t\t\tconst location = data + offset >= 100 ? 99 : data + offset;\r\n\r\n\t\t\tregisters.ac = memory[location];\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t// LDA\r\n\t\tcase 5:\r\n\t\t\tregisters.ac = memory[data];\r\n\t\t\tbreak;\r\n\t\t// BRA\r\n\t\tcase 6:\r\n\t\t\tregisters.pc = data;\r\n\t\t\tbreak;\r\n\t\t// BRZ\r\n\t\tcase 7:\r\n\t\t\tif(registers.ac === 0)\r\n\t\t\t\tregisters.pc = data;\r\n\t\t\tbreak;\r\n\t\t// BRP\r\n\t\tcase 8:\r\n\t\t\tif(registers.ac >= 0)\r\n\t\t\t\tregisters.pc = data;\r\n\t\t\tbreak;\r\n\t\t// INP / OUT\r\n\t\tcase 9:\r\n\t\t\tif(data === 1) {\r\n\t\t\t\twaitingForInput = true;\r\n\t\t\t}\r\n\t\t\telse if(data === 2) {\r\n\t\t\t\toutput += registers.ac + \" \";\r\n\t\t\t}\r\n\t\t\telse if(data === 12) {\r\n\t\t\t\toutput += String.fromCharCode(registers.ac);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t// NOP\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\treturn {\r\n\t\tmemory,\r\n\t\tip: registers.pc,\r\n\t\tregisters,\r\n\t\toutput,\r\n\t\thalt,\r\n\t\twaitingForInput\r\n\t}\r\n}","export const languageDef = {\r\n\tdefaultToken: \"\",\r\n\tkeywords: [\r\n\t\t\"LDA\", \"STA\", \"LOA\", \"ADD\", \"SUB\", \"INP\", \"OUT\", \"OTC\", \"HLT\", \"BRZ\", \"BRP\", \"BRA\", \"DAT\"\r\n\t].map(x => [x, x.toLowerCase()]).flat(),\r\n\ttokenizer: {\r\n\t\troot: [\r\n\t\t\t{ include: '@whitespace' },\r\n\t\t\t[/[a-zA-Z][a-zA-Z0-9]*/, {\r\n\t\t\t\tcases: {\r\n\t\t\t\t\t\"@keywords\": \"keyword\",\r\n\t\t\t\t\t\"@default\": \"type.identifier\"\r\n\t\t\t\t}\r\n\t\t\t}],\r\n\t\t\t[/\\d+/, 'number'],\r\n\t\t],\r\n\t\twhitespace: [\r\n\t\t\t[/[ \\t\\r\\n]+/, 'white'],\r\n\t\t\t[/\\/\\/.*$/,    'comment'],\r\n\t\t],\r\n\t}\r\n}\r\n\r\nexport const configuration = {\r\n\tcomments: {\r\n\t  lineComment: \"//\",\r\n\t},\r\n}","export const examples = {\r\n\t\"Addition\": [\r\n\t\t\"// Input two numbers, sum them, and output the result\",\r\n\t\t\"        INP\",\r\n\t\t\"        STA FIRST\",\r\n\t\t\"        INP\",\r\n\t\t\"        ADD FIRST\",\r\n\t\t\"        OUT\",\r\n\t\t\"        HLT\",\r\n\t\t\"FIRST   DAT 0\",\r\n\t].join(\"\\n\"),\r\n\t\"0..N\": [\r\n\t\t\"// Implements printing 0..N (inc. exc.)\",\r\n\t\t\"// Similar to for(int i = 0; i < N; i++) or for i in range(N)\",\r\n\t\t\"// in high-level languages\",\r\n\t\t\"        INP\",\r\n\t\t\"        STA EVAL\",\r\n\t\t\"\",\r\n\t\t\"// Compare SVAL and EVAL, and if SVAL is equal to or greater than EVAL,\",\r\n\t\t\"// Jump to END\",\r\n\t\t\"TOP     LDA SVAL\",\r\n\t\t\"        SUB EVAL\",\r\n\t\t\"        BRP END\",\r\n\t\t\"\",\r\n\t\t\"// Output SVAL and increment it by one, looping back to TOP\",\r\n\t\t\"        LDA SVAL\",\r\n\t\t\"        OUT\",\r\n\t\t\"        ADD ONE\",\r\n\t\t\"        STA SVAL\",\r\n\t\t\"        BRA TOP\",\r\n\t\t\"\",\r\n\t\t\"END     HLT\",\r\n\t\t\"\",\r\n\t\t\"// Variables: Start Value and End Value\",\r\n\t\t\"SVAL    DAT 0\",\r\n\t\t\"EVAL    DAT 0\",\r\n\t\t\"// Constant 1\",\r\n\t\t\"ONE     DAT 1\",\r\n\t].join(\"\\n\"),\r\n\t\"Max\": [\r\n\t\t\"// Implements max(a, b) -> returns the higher value of the two.\",\r\n\t\t\"        INP\",\r\n\t\t\"        STA FIRST\",\r\n\t\t\"        INP\",\r\n\t\t\"        STA SECOND\",\r\n\t\t\"// Subtract second - first, and if positive second must be greater\",\r\n\t\t\"        SUB FIRST\",\r\n\t\t\"        BRP GREATER\",\r\n\t\t\"// Otherwise, output first and skip over printing second\",\r\n\t\t\"        LDA FIRST\",\r\n\t\t\"        OUT\",\r\n\t\t\"        BRA END\",\r\n\t\t\"\",\r\n\t\t\"// Output second\",\r\n\t\t\"GREATER LDA SECOND\",\r\n\t\t\"        OUT\",\r\n\t\t\"\",\r\n\t\t\"END     HLT\",\r\n\t\t\"\",\r\n\t\t\"// Variables\",\r\n\t\t\"FIRST   DAT 0\",\r\n\t\t\"SECOND  DAT 0\",\r\n\t].join(\"\\n\"),\r\n\t\"Multiply\": [\r\n\t\t\"// Multiplies two numbers, val1 and val2, together\",\r\n\t\t\"\",\r\n\t\t\"// Take in two inputs\",\r\n\t\t\"        INP\",\r\n\t\t\"        STA VAL1\",\r\n\t\t\"        INP\",\r\n\t\t\"        STA VAL2\",\r\n\t\t\"\",\r\n\t\t\"// If val2 is 0, branch to the end\",\r\n\t\t\"LOOP    BRZ END\",\r\n\t\t\"// Add val1 to product and store back in product\",\r\n\t\t\"        LDA PRODUCT\",\r\n\t\t\"        ADD VAL1\",\r\n\t\t\"        STA PRODUCT\",\r\n\t\t\"// decrement val2 by one\",\r\n\t\t\"        LDA VAL2\",\r\n\t\t\"        SUB ONE\",\r\n\t\t\"        STA VAL2\",\r\n\t\t\"// Loop back to the top of the loop\",\r\n\t\t\"        BRA LOOP\",\r\n\t\t\"\",\r\n\t\t\"// When the loop is finished, output the product\",\r\n\t\t\"END     LDA PRODUCT\",\r\n\t\t\"        OUT\",\r\n\t\t\"        HLT\",\r\n\t\t\"\",\r\n\t\t\"// Variables\",\r\n\t\t\"VAL1    DAT 0\",\r\n\t\t\"VAL2    DAT 0\",\r\n\t\t\"PRODUCT DAT 0\",\r\n\t\t\"\",\r\n\t\t\"// Constant 1\",\r\n\t\t\"ONE     DAT 1\",\r\n\t].join(\"\\n\"),\r\n\t\"Divide\": [\r\n\t\t\"// Input two values\",\r\n\t\t\"      INP\",\r\n\t\t\"      STA VAL1\",\r\n\t\t\"      INP\",\r\n\t\t\"      STA VAL2\",\r\n\t\t\"      \",\r\n\t\t\"// Loop, subtracting the val2 and counting iterations\",\r\n\t\t\"\",\r\n\t\t\"LOOP  LDA VAL1\",\r\n\t\t\"      SUB VAL2\",\r\n\t\t\"// Stop looping when the subtraction result is negative\",\r\n\t\t\"      BRP BODY\",\r\n\t\t\"      BRA DONE\",\r\n\t\t\"\",\r\n\t\t\"BODY  STA VAL1\",\r\n\t\t\"      LDA COUNT\",\r\n\t\t\"      ADD ONE\",\r\n\t\t\"      STA COUNT\",\r\n\t\t\"      BRA LOOP\",\r\n\t\t\"\",\r\n\t\t\"// After looping, print the count and the remainder (left in val1)\",\r\n\t\t\"DONE  LDA COUNT\",\r\n\t\t\"      OUT\",\r\n\t\t\"      LDA VAL1\",\r\n\t\t\"      BRZ END\",\r\n\t\t\"      OUT\",\r\n\t\t\"END   HLT\",\r\n\t\t\"\",\r\n\t\t\"// Variables\",\r\n\t\t\"VAL1  DAT 0\",\r\n\t\t\"VAL2  DAT 0\",\r\n\t\t\"COUNT DAT 0\",\r\n\t\t\"// Constant 1\",\r\n\t\t\"ONE   DAT 1\",\r\n\t].join(\"\\n\"),\r\n\t\"ASCII\": [\r\n\t\t\"// Loop through and print all printable ASCII characters\",\r\n\t\t\"// Similar to 0..N example, but from 33..127\",\r\n\t\t\"\",\r\n\t\t\"// Compare FPRINT and LPRINT, branch to end if FPRINT is greater or equal\",\r\n\t\t\"TOP     LDA FPRINT\",\r\n\t\t\"        SUB LPRINT\",\r\n\t\t\"        BRP END\",\r\n\t\t\"\",\r\n\t\t\"// Print character from ASCII code\",\r\n\t\t\"        LDA FPRINT\",\r\n\t\t\"        OTC\",\r\n\t\t\"// Increment FPRINT and loop\",\r\n\t\t\"        ADD ONE\",\r\n\t\t\"        STA FPRINT\",\r\n\t\t\"        BRA TOP\",\r\n\t\t\"\",\r\n\t\t\"END     HLT\",\r\n\t\t\"\",\r\n\t\t\"// Variable FPRINT counts starting from 33\",\r\n\t\t\"FPRINT  DAT 33\",\r\n\t\t\"// Constant LPRINT is the last printable character + 1\",\r\n\t\t\"LPRINT  DAT 127\",\r\n\t\t\"// Constant 1\",\r\n\t\t\"ONE     DAT 1\",\r\n\t].join(\"\\n\"),\r\n\t\"Hello World\": [\r\n\t\t\"// Prints the string \\\"Hello, World!\\\" to the output\",\r\n\t\t\"// Loop, checking if the OFFSET is less than LENGTH\",\r\n\t\t\"BEGIN   LDA LENGTH\",\r\n\t\t\"        SUB OFFSET\",\r\n\t\t\"        BRZ END\",\r\n\t\t\"        BRP PRINT\",\r\n\t\t\"        BRA END\",\r\n\t\t\"\",\r\n\t\t\"// Offset from START by OFFSET to extract the character\",\r\n\t\t\"// The same as START[OFFSET] in high-level languages\",\r\n\t\t\"PRINT   LDA OFFSET\",\r\n\t\t\"// LOA = Load Offset To Accumulator\",\r\n\t\t\"        LOA START\",\r\n\t\t\"// OTC = Output accumulator as character (e.g. 65 -> A)\",\r\n\t\t\"        OTC\",\r\n\t\t\"        LDA OFFSET\",\r\n\t\t\"        ADD ONE\",\r\n\t\t\"        STA OFFSET\",\r\n\t\t\"        BRA BEGIN\",\r\n\t\t\"\",\r\n\t\t\"END     HLT\",\r\n\t\t\"\",\r\n\t\t\"// Variable\",\r\n\t\t\"OFFSET  DAT 0\",\r\n\t\t\"// Constant: Encode \\\"Hello, World!\\\" as character codes, one byte after the other\",\r\n\t\t\"START   DAT 72\",\r\n\t\t\"        DAT 101\",\r\n\t\t\"        DAT 108\",\r\n\t\t\"        DAT 108\",\r\n\t\t\"        DAT 111\",\r\n\t\t\"        DAT 44\",\r\n\t\t\"        DAT 32\",\r\n\t\t\"        DAT 87\",\r\n\t\t\"        DAT 111\",\r\n\t\t\"        DAT 114\",\r\n\t\t\"        DAT 108\",\r\n\t\t\"        DAT 100\",\r\n\t\t\"        DAT 33\",\r\n\t\t\"// Constant length of the string\",\r\n\t\t\"LENGTH  DAT 13\",\r\n\t\t\"// Constant 1\",\r\n\t\t\"ONE     DAT 1\",\r\n\t].join(\"\\n\")\r\n}","import './Description.css';\r\n\r\nexport default function Description() {\r\n\treturn (\r\n\t\t<div className=\"description\">\r\n\t\t\t<section>\r\n\t\t\t\t<h2>Memory</h2>\r\n\t\t\t\t<p>\r\n\t\t\t\t\tThe memory in the LMC is made from 100 address/mailboxes, from 0 to 99.<br/>\r\n\t\t\t\t\tEach value in memory can be up to 3 digits (decimal) long.<br/>\r\n\t\t\t\t\tAs the LMC follows Von Neumann architecture, both the data and instructions are stored in the same memory.<br/>\r\n\t\t\t\t</p>\r\n\t\t\t</section>\r\n\t\t\t<section>\r\n\t\t\t\t<h2>Registers</h2>\r\n\t\t\t\t<p>\r\n\t\t\t\t\tEach register has a specific purpose and may only hold one value.\r\n\t\t\t\t</p>\r\n\t\t\t\t<ul>\r\n\t\t\t\t\t<li>The Program Counter Register holds the address of the next instruction to be fetched.</li>\r\n\t\t\t\t\t<li>The Instruction Register holds the instruction part of the value fetched from memory (the first digit).</li>\r\n\t\t\t\t\t<li>The Address Register holds the address/data of the value fetched from memory (the second &amp; third digit).</li>\r\n\t\t\t\t\t<li>The Accumulator Register holds the results of instructions, and is used with instructions such as ADD for the first operand.</li>\r\n\t\t\t\t</ul>\r\n\t\t\t</section>\r\n\t\t\t<section>\r\n\t\t\t\t<h2>Assembly Language</h2>\r\n\t\t\t\t<p>\r\n\t\t\t\t\tThe Assembly Language used for the LMC is simplistic.\r\n\t\t\t\t\tIt can only recognise line comments (//), integer numbers, labels, and instructions.\r\n\t\t\t\t\tIf a line has a label it must come before the instruction.\r\n\t\t\t\t\tUnlike in some other LMC assembly languages, DAT must always take a value.\r\n\t\t\t\t\tThere can only be one instruction and label per line, and each instruction takes either 0 or 1 arguments.\r\n\t\t\t\t</p>\r\n\t\t\t</section>\r\n\t\t\t<section>\r\n\t\t\t\t<h2>Instructions - Standard</h2>\r\n\t\t\t\t<div>\r\n\t\t\t\t\t<h3>HLT</h3>\r\n\t\t\t\t\t<small>Encoding: 000</small>\r\n\t\t\t\t\t<p>\r\n\t\t\t\t\t\tThe halt instruction (HLT) stops the execution of the program.\r\n\t\t\t\t\t</p>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div>\r\n\t\t\t\t\t<h3>ADD</h3>\r\n\t\t\t\t\t<small>Encoding: 1xx</small>\r\n\t\t\t\t\t<p>\r\n\t\t\t\t\t\tThe add instruction (ADD) takes the value in the accumulator and the value at the given address and adds them.\r\n\t\t\t\t\t\tThe result is stored back into the accumulator.\r\n\t\t\t\t\t</p>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div>\r\n\t\t\t\t\t<h3>SUB</h3>\r\n\t\t\t\t\t<small>Encoding: 2xx</small>\r\n\t\t\t\t\t<p>\r\n\t\t\t\t\t\tThe subtract instruction (SUB) takes the value in the accumulator and the value at the given address and subtracts them.\r\n\t\t\t\t\t\tThe result is stored back into the accumulator.\r\n\t\t\t\t\t</p>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div>\r\n\t\t\t\t\t<h3>STA</h3>\r\n\t\t\t\t\t<small>Encoding: 3xx</small>\r\n\t\t\t\t\t<p>\r\n\t\t\t\t\t\tThe store accumulator instruction (STA) takes the value in the accumulator and stores it into the given memory address.\r\n\t\t\t\t\t\tThe value of the accumulator does not change.\r\n\t\t\t\t\t</p>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div>\r\n\t\t\t\t\t<h3>LDA</h3>\r\n\t\t\t\t\t<small>Encoding: 5xx</small>\r\n\t\t\t\t\t<p>\r\n\t\t\t\t\t\tThe load accumulator instruction (LDA) takes the value at the given memory address and stores it into the accumulator.\r\n\t\t\t\t\t</p>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div>\r\n\t\t\t\t\t<h3>BRA</h3>\r\n\t\t\t\t\t<small>Encoding: 6xx</small>\r\n\t\t\t\t\t<p>\r\n\t\t\t\t\t\tThe branch always instruction (BRA) sets the program counter to the given address.\r\n\t\t\t\t\t\tThe value of the accumulator does not change.\r\n\t\t\t\t\t</p>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div>\r\n\t\t\t\t\t<h3>BRZ</h3>\r\n\t\t\t\t\t<small>Encoding: 7xx</small>\r\n\t\t\t\t\t<p>\r\n\t\t\t\t\t\tThe branch if zero instruction (BRZ) sets the program counter to the given address if the accumulator's value is 0.\r\n\t\t\t\t\t\tThe value of the accumulator does not change.\r\n\t\t\t\t\t</p>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div>\r\n\t\t\t\t\t<h3>BRP</h3>\r\n\t\t\t\t\t<small>Encoding: 8xx</small>\r\n\t\t\t\t\t<p>\r\n\t\t\t\t\t\tThe branch if positive instruction (BRP) sets the program counter to the given address if the accumulator's value is positive,\r\n\t\t\t\t\t\tincluding 0 (i.e. the value is not negative).\r\n\t\t\t\t\t\tThe value of the accumulator does not change.\r\n\t\t\t\t\t</p>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div>\r\n\t\t\t\t\t<h3>INP</h3>\r\n\t\t\t\t\t<small>Encoding: 901</small>\r\n\t\t\t\t\t<p>\r\n\t\t\t\t\t\tThe input instruction (INP) waits for the user to enter a value, then stores this value into the accumulator.\r\n\t\t\t\t\t</p>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div>\r\n\t\t\t\t\t<h3>OUT</h3>\r\n\t\t\t\t\t<small>Encoding: 902</small>\r\n\t\t\t\t\t<p>\r\n\t\t\t\t\t\tThe output instruction (OUT) takes the accumulator's value and outputs it to the output box.\r\n\t\t\t\t\t\tThe value of the accumulator does not change.\r\n\t\t\t\t\t</p>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div>\r\n\t\t\t\t\t<h3>DAT</h3>\r\n\t\t\t\t\t<small>Encoding: xxx</small>\r\n\t\t\t\t\t<p>\r\n\t\t\t\t\t\tThe data instruction (DAT) encodes its operand as into the memory. \r\n\t\t\t\t\t\tIt does not perform an operation.\r\n\t\t\t\t\t</p>\r\n\t\t\t\t</div>\r\n\t\t\t</section>\r\n\t\t\t<section>\r\n\t\t\t\t<h2>Instructions - Non Standard</h2>\r\n\t\t\t\t<div>\r\n\t\t\t\t\t<h3>OTC</h3>\r\n\t\t\t\t\t<small>Encoding: 912</small>\r\n\t\t\t\t\t<p>\r\n\t\t\t\t\t\tThe output character instruction (OUT) takes the accumulator's value and converts it to a character (using it as a character code).\r\n\t\t\t\t\t\tThis character is then outputted to the output box.\r\n\t\t\t\t\t\tThe value of the accumulator does not change.\r\n\t\t\t\t\t</p>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div>\r\n\t\t\t\t\t<h3>LOA</h3>\r\n\t\t\t\t\t<small>Encoding: 4xx</small>\r\n\t\t\t\t\t<p>\r\n\t\t\t\t\t\tThe load offset to accumulator instruction (LOA) takes the accumulator's value and adds it to the given address.\r\n\t\t\t\t\t\tThen this computed address' value is stored into the accumulator.\r\n\t\t\t\t\t</p>\r\n\t\t\t\t</div>\r\n\t\t\t</section>\r\n\t\t</div>\r\n\t)\r\n}\r\n","import './App.css';\n\nimport Editor from \"@monaco-editor/react\";\nimport { useRef, useState } from 'react';\nimport { assemble } from './assembler';\nimport { step } from './emulator';\nimport { languageDef, configuration } from './editor-config'\nimport { examples } from './examples';\nimport Description from './Description';\n\nconst defaultString = [\n\t\"// Input two numbers, sum them, and output the result\",\n\t\"        INP\",\n\t\"        STA FIRST\",\n\t\"        INP\",\n\t\"        ADD FIRST\",\n\t\"        OUT\",\n\t\"        HLT\",\n\t\"FIRST   DAT 0\"\n].join(\"\\n\");\n\nconst editorWillMount = monaco => {\n\tif (!monaco.languages.getLanguages().some(({ id }) => id === 'lmc')) {\n\t\t// Register a new language\n\t\tmonaco.languages.register({ id: 'lmc' })\n\t\t// Register a tokens provider for the language\n\t\tmonaco.languages.setMonarchTokensProvider('lmc', languageDef)\n\t\t// Set the editing configuration for the language\n\t\tmonaco.languages.setLanguageConfiguration('lmc', configuration)\n\t}\n}\n\nfunction App() {\n\n\tconst editorRef = useRef(null);\n\n\tconst [memory, setMemory] = useState(Array(100).fill(0));\n\tconst [currentIp, setCurrentIp] = useState(0)\n\tconst [registers, setRegisters] = useState({\n\t\t\"pc\": 0,\n\t\t\"ir\": 0,\n\t\t\"ar\": 0,\n\t\t\"ac\": 0\n\t})\n\tconst [output, setOutput] = useState(\"\")\n\tconst [error, setError] = useState(\"\")\n\tconst [input, setInput] = useState(\"\")\n\tconst [waitingForInput, setWaitingForInput] = useState(false)\n\tconst [isHalted, setHalted] = useState(false)\n\tconst [changedMemoryAddresses, setChangedMemoryAddresses] = useState([])\n\tconst [isAccumulatorChanged, setAccumulatorChanged] = useState(false)\n\tconst [inputSpeed, setInputSpeed] = useState(\"60\")\n\tconst [speed, setSpeed] = useState(60)\n\tconst submitRef = useRef(null)\n\tconst loopRef = useRef(null)\n\n\tconst handleEditorDidMount = (editor, _monaco) => {\n\t\teditorRef.current = editor;\n\t}\n\n\tconst getColourBorder = (condition, subcondition) => {\n\t\tif (condition) {\n\t\t\tif (subcondition) {\n\t\t\t\treturn \"red-border\";\n\t\t\t}\n\t\t\treturn \"green-border\";\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tconst onInputChanged = (event) => {\n\t\tsetInput(event.target.value)\n\t}\n\n\tconst onInputSubmitted = (event) => {\n\t\tsubmitRef.current = input.charAt(0) === '-' ? input.substring(0, 4) : input.substring(0, 3)\n\t\tsetInput(\"\")\n\t\tevent.preventDefault()\n\t}\n\n\tconst onSpeedChanged = (event) => {\n\t\tsetInputSpeed(event.target.value)\n\t}\n\n\tconst onSpeedSubmitted = (event) => {\n\t\tlet speed = parseInt(inputSpeed) || 60\n\t\tif(speed <= 0) {\n\t\t\tspeed = 60\n\t\t}\n\t\tsetSpeed(speed)\n\t\tevent.preventDefault()\n\t}\n\n\tconst selectedExampleChanged = (event) => {\n\t\teditorRef.current.setValue(examples[event.target.value])\n\t}\n\n\tconst assembleCode = () => {\n\t\tconst assembleResult = assemble(editorRef.current.getValue())\n\n\t\tif(!assembleResult.error) {\n\t\t\tsetMemory(assembleResult.memory)\n\t\t\tsetError(\"\")\n\t\t}\n\t\telse {\n\t\t\tsetError(`[${assembleResult.errorLoc.line}]: ${assembleResult.error}`)\n\t\t}\n\t}\n\n\tconst runCode = () => {\n\t\tif(error !== \"\") return;\n\t\tlet localMem = memory;\n\t\tlet ip = 0;\n\t\tlet localReg = {\n\t\t\t\"pc\": 0,\n\t\t\t\"ir\": 0,\n\t\t\t\"ar\": 0,\n\t\t\t\"ac\": 0\n\t\t};\n\t\tlet halt = false;\n\t\tlet out = \"\"\n\n\t\tlet waiting = false\n\t\tloopRef.current = setInterval(() => {\n\t\t\tif (waiting && !submitRef.current)\n\t\t\t\treturn;\n\n\t\t\tconst memoryBefore = [...localMem];\n\t\t\tconst accumulatorBefore = localReg[\"ac\"];\n\n\t\t\t({ memory: localMem, ip, registers: localReg, halt, output: out, waitingForInput: waiting } = step(localMem, ip, localReg, out, waiting, submitRef.current))\n\t\t\tif (submitRef.current)\n\t\t\t\tsubmitRef.current = null\n\n\t\t\tif (halt || ip >= 100) {\n\t\t\t\tclearInterval(loopRef.current)\n\t\t\t\tloopRef.current = null\n\t\t\t}\n\n\t\t\tif (ip >= 100) ip = 99;\n\t\t\tsetCurrentIp(ip)\n\t\t\tsetRegisters(localReg)\n\t\t\tsetMemory(localMem)\n\t\t\tsetOutput(out)\n\t\t\tsetWaitingForInput(waiting)\n\t\t\tsetHalted(halt)\n\n\t\t\tlet changedMem = []\n\t\t\tfor(let i = 0; i < localMem.length; i++) {\n\t\t\t\tif(memoryBefore[i] !== localMem[i]) {\n\t\t\t\t\tchangedMem.push(i)\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetChangedMemoryAddresses(changedMem)\n\t\t\tsetAccumulatorChanged(accumulatorBefore !== localReg[\"ac\"])\n\t\t}, 1000 / speed)\n\t}\n\n\tconst stopCode = () => {\n\t\tclearInterval(loopRef.current)\n\t}\n\n\tconst stepCode = () => {\n\t\tif(error !== \"\") return;\n\t\tclearInterval(loopRef.current)\n\n\t\tif (waitingForInput && !submitRef.current)\n\t\t\treturn;\n\t\tif (isHalted || currentIp >= 100)\n\t\t\treturn;\n\n\t\tlet localMem = memory;\n\t\tlet ip = currentIp;\n\t\tlet localReg = registers;\n\t\tlet halt = isHalted;\n\t\tlet out = \"\"\n\n\t\tlet waiting = waitingForInput;\n\n\t\tconst memoryBefore = [...localMem];\n\t\tconst accumulatorBefore = localReg[\"ac\"];\n\n\t\t({ memory: localMem, ip, registers: localReg, halt, output: out, waitingForInput: waiting } = step(localMem, ip, localReg, out, waiting, submitRef.current))\n\t\tif (submitRef.current)\n\t\t\tsubmitRef.current = null\n\n\t\tif (halt || ip >= 100) {\n\t\t\tclearInterval(loopRef.current)\n\t\t\tloopRef.current = null\n\t\t}\n\n\t\tif (ip >= 100) ip = 99;\n\t\tsetCurrentIp(ip)\n\t\tsetRegisters(localReg)\n\t\tsetMemory(localMem)\n\t\tsetOutput(out)\n\t\tsetWaitingForInput(waiting)\n\t\tsetHalted(halt)\n\t\t\n\t\tlet changedMem = []\n\t\tfor(let i = 0; i < localMem.length; i++) {\n\t\t\tif(memoryBefore[i] !== localMem[i]) {\n\t\t\t\tchangedMem.push(i)\n\t\t\t}\n\t\t}\n\t\tsetChangedMemoryAddresses(changedMem)\n\t\tsetAccumulatorChanged(accumulatorBefore !== localReg[\"ac\"])\n\t}\n\n\tconst reset = () => {\n\t\tstopCode()\n\t\tassembleCode()\n\t\tsetCurrentIp(0)\n\t\tsetRegisters({\n\t\t\t\"pc\": 0,\n\t\t\t\"ir\": 0,\n\t\t\t\"ar\": 0,\n\t\t\t\"ac\": 0\n\t\t})\n\t\tsetOutput(\"\")\n\t\tsetWaitingForInput(false)\n\t\tsetHalted(false)\n\t\tsetChangedMemoryAddresses([])\n\t\tsetAccumulatorChanged(false)\n\t}\n\n\tconst renderMemory = () => {\n\t\tconst per10mem = [];\n\t\tfor (let i = 0; i < memory.length; i += 10) {\n\t\t\tconst chunk = memory.slice(i, i + 10);\n\t\t\tper10mem.push(chunk);\n\t\t}\n\n\t\treturn per10mem.map((values, i) => {\n\t\t\treturn <div className=\"memory-row\" key={\"memory\" + i}>\n\t\t\t\t<p className=\"memory-item\">{i * 10}: </p>\n\t\t\t\t<>{\n\t\t\t\t\tvalues.map((value, j) => <p className={`memory-item ${getColourBorder(i * 10 + j === currentIp, isHalted)} ${changedMemoryAddresses.includes(i * 10 + j) ? \"yellow-border\" : \"\"}`} key={\"item\" + i * 10 + j}>{value}</p>)\n\t\t\t\t}</>\n\t\t\t</div>\n\t\t})\n\t}\n\n\tconst renderRegisters = () => {\n\t\tconst regToName = {\n\t\t\t\"pc\": \"Program Counter\",\n\t\t\t\"ir\": \"Instruction\",\n\t\t\t\"ar\": \"Address\",\n\t\t\t\"ac\": \"Accumulator\"\n\t\t}\n\n\t\treturn Object.entries(registers).map(([register, value]) => <p style={{ minWidth: regToName[register].length + 2 + 3 + \"ch\" }} className={`register ${getColourBorder(register === \"pc\", isHalted)} ${((register === \"ac\" && isAccumulatorChanged) ? \"yellow-border\" : \"\")}`} key={register}>{regToName[register]}: {value}</p>)\n\t}\n\n\tconst renderProgramSelectOptions = () => Object.keys(examples).map(e => <option value={e} key={e}>{e}</option>)\n\n\treturn (\n\t\t<div className=\"App\">\n\t\t\t<h1 className=\"title\">Little Man Computer</h1>\n\t\t\t<div className=\"buttons\">\n\t\t\t\t<button onClick={reset}>Assemble To RAM (reset)</button>\n\t\t\t\t<button onClick={runCode}>Run</button>\n\t\t\t\t<button onClick={() => { if(error !== \"\") return; stopCode(); setHalted(true); }}>Stop</button>\n\t\t\t\t<button onClick={stepCode}>Step</button>\n\t\t\t</div>\n\t\t\t<main>\n\t\t\t\t<Editor height=\"90vh\" width=\"45vw\" language=\"lmc\" theme=\"vs-dark\" defaultValue={defaultString} beforeMount={editorWillMount} onMount={handleEditorDidMount} />\n\t\t\t\t<div className=\"monitor\">\n\t\t\t\t\t<div className=\"forms\">\n\t\t\t\t\t\t<form onSubmit={onInputSubmitted} className=\"input-form\" autoComplete=\"off\" autoCapitalize=\"off\" autoCorrect=\"off\">\n\t\t\t\t\t\t\t<label htmlFor=\"ioinput\" className={waitingForInput ? \"green-border\" : \"\"}>Input</label>\n\t\t\t\t\t\t\t<input type=\"text\" name=\"ioinput\" value={input} onChange={onInputChanged} />\n\t\t\t\t\t\t</form>\n\t\t\t\t\t\t<form onSubmit={onSpeedSubmitted}>\n\t\t\t\t\t\t\t<label htmlFor=\"runspeed\">Speed ({speed}Hz)</label>\n\t\t\t\t\t\t\t<input type=\"number\" name=\"runspeed\" value={inputSpeed} onChange={onSpeedChanged} />\n\t\t\t\t\t\t</form>\n\t\t\t\t\t\t<form>\n\t\t\t\t\t\t\t<label htmlFor=\"selectprogram\">Example</label>\n\t\t\t\t\t\t\t<select onChange={selectedExampleChanged}>\n\t\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t\t{renderProgramSelectOptions()}\n\t\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t\t</select>\n\t\t\t\t\t\t</form>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className=\"mem-reg-container\">\n\t\t\t\t\t\t<div className=\"memory\">\n\t\t\t\t\t\t\t<h2>Memory</h2>\n\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t{renderMemory()}\n\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className=\"registers\">\n\t\t\t\t\t\t\t<h2>Registers</h2>\n\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t{renderRegisters()}\n\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className=\"output-box\">\n\t\t\t\t\t\t<h2>Output</h2>\n\t\t\t\t\t\t<p className={`output ${error !== \"\" ? \"error-output\" : \"\"}`}>\n\t\t\t\t\t\t\t{error === \"\" ? output : error}\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</main>\n\t\t\t<Description />\n\t\t\t<footer>\n\t\t\t\tOpen Source on <a href=\"https://github.com/qco-dev/lmc\">Github</a>.\n\t\t\t</footer>\n\t\t</div>\n\t);\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}